\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename rcp_ja.info
@settitle RCP User Manual
@setchapternewpage odd
@c %**end of header

@c XXX This is a euc-jp file. I know it is better to use iso-2022-jp 
@c XXX for htmlizing, but makeinfo doesn't work with it. 
@c XXX My configuration problem or need unofficial patch?

@c XXX Quick hack for Japanese translation. 
@c XXX Use @ifset ja for the contents only in Japanese version and
@c XXX the transrator's comment.
@clear ja
@set ja

@c This is *so* much nicer :)
@footnotestyle end

@c Version values, for easy modification
@c NOTE: The 'UPDATED' value is updated by the 'time-stamp' function.
@c       If you change it by hand, the modifications will not stay.
@set VERSION $Revision: 1.2 $
@set UPDATED 2000 年 5 月 31 日 (Wed)
@c XXX VERSION and UPDATED are Japanese version's version and update date.
@c XXX If we need English version's one, we MUST use literal version and
@c XXX date strings.

@c Entries for @command{install-info} to use
@direntry
* RCP: (rcp).                   Emacs remote file access via rsh and rcp.
@end direntry

@c Macro to make formatting of the rcp program name consistent.
@macro rcp
@sc{rcp}
@end macro

@c Copying permissions, et al
@ifinfo
This file documents @rcp{}, a remote file editing package for Emacs and
XEmacs.
     
Copyright @copyright{} 1999, 2000 Free Software Foundation, Inc.
     
Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.
     
@ignore 
Permission is granted to process this file through TeX and print the
results, provided the printed document carries a copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).
   
@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
sections entitled ``Copying'' and ``GNU General Public License'' are
included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.
     
Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.
@end ifinfo

@tex

@titlepage
@title @rcp{} User Manual
@subtitle Last updated @value{UPDATED}

@author by Daniel Pittman
@author based on documentation by Kai Gro@ss{}johann
@page

@vskip 0pt plus 1filll
Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.
     
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
sections entitled ``Copying'' and ``GNU General Public License'' are
included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.
     
Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.

@end titlepage
@page

@end tex

@ifnottex
@node Top, Copying, (dir), (dir)
@top @rcp{} ユーザーマニュアル

このパッケージは @cite{ange-ftp} や @cite{EFS} に似たリモートファイルの
編集機能を提供します。

違うのはファイルの転送方法です。ange-ftp は、ローカル、リモートホスト間の
ファイル転送に FTP を使用します。しかし、@rcp{} は @command{rsh} と 
@command{rcp}、あるいは他の同じようなプログラム、例えば @command{ssh} や 
@command{scp}を使用します。

これは @rcp{} のマニュアルのバージョン 1.22 で、最後に更新されたのは
2000 年 5 月 27 日 (Sat)です。

@ifset ja
@c XXX これは @rcp{} のマニュアルのバージョン @value{VERSION} で、最後に
@c XXX 更新されたのは @value{UPDATED} です。
[訳者注] 日本語訳のバージョンは @value{VERSION}で、最終更新日時は @value{UPDATED} です。
@end ifset

このドキュメントの最新バージョンは web サイト
@url{http://ls6-www.informatik.uni-dortmund.de/~grossjoh/emacs/rcp.html}
にあります。

@ifhtml
最新の @rcp{} は
@url{ftp://ls6-ftp.cs.uni-dortmund.de/pub/src/emacs/rcp.tar.gz} 
から入手できます。詳細は @ref{Obtaining @rcp{}} を参照してください。
CVS サーバーについての説明もあります。
@end ifhtml

@rcp{}のためのメーリングリスト @email{emacs-rcp@@ls6.cs.uni-dortmund.de}が
あります。アーカイブは 
@url{http://www.mail-archive.com/emacs-rcp@@ls6.cs.uni-dortmund.de/} 
にあります。

@end ifnottex


@menu
* Copying::			@rcp{} の配布条件
* Overview::			@rcp{} で可能な事、不可能な事

エンドユーザー向け:
* Obtaining @rcp{}::		@rcp{} の入手方法
* Installation::		@rcp{} のインストール
* Configuration::		@rcp{} の設定
* Usage::			@rcp{} の使い方
* Bug Reports::			バグや問題の報告
* Frequently Asked Questions::	よくある質問とその答

開発者向け:
* Version Control::		リモートバージョンコントロールの内部動作
* Files directories and paths::	ファイル名、ディレクトリ、パス名がどのように
                                変換され(mangled)、管理されるか
* Issues::			
@end menu


@node Copying, Overview, Top, Top
@chapter @rcp{} の配布条件

Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.

rcp.el is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2, or (at your option) any later
version.

rcp.el is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
more details.

You should have received a copy of the GNU General Public License along
with GNU Emacs; see the file COPYING. If not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
USA.


@node Overview, Obtaining @rcp{}, Copying, Top
@chapter @rcp の概要

@rcp{} をインストールすると、リモートマシン上のファイルに、ローカル
ファイルと同じようにアクセスできます。編集のためのリモートファイル
システムへのアクセス、バージョンコントロール、@command{dired} が
透過的に可能です。

リモートマシンへのアクセスには、@command{rsh} や @command{rlogin}、
@command{telnet} コマンド、あるいはこれらに類似した接続方法が使用
されます。これらは ASCII を通過させる事が可能でなければなりませんが、
8-bit クリーンである必要はありません。

このパッケージは外部への @command{ssh} 接続をサポートします。これは、
このパッケージのもっとも一般的な使い方のひとつです。特に @command{ftp}
アクセスが許可されていない場合、他のマシンへの比較的セキュアなアクセス
が可能です。

@rcp{} によって実行されるアクティビティのほとんどは、リモートログイン
が可能で、端末上で実行できることだけを要求します。リモートファイルに
アクセスするために @rcp {} は、ファイルの内容を一時的にローカルマシン
上に転送します。

@rcp{} は、さまざまな方法でマシン間のファイル転送をおこないます。これら
の方法は簡単に選択でき、あなたのニーズとマシン環境に応じて使いわける事
ができます。

もっとも速い転送メソッドは、リモートファイルの転送パッケージ、たとえば
@command{rcp}、@command{scp}、@command{rsync} を使うものです。これらの
メソッドは、ファイルのコピーコマンドがリモートマシンのパスワードをたず
ねない場合にのみ有効です。

もし、リモートコピーメソッドが使えない場合のために、@rcp {} は、シェル
を直接使用した、符号化された転送方法をサポートしています。これを使う
ためには、@command{mimencode} か @command{uuencode} がリモートマシン
上に存在しなければなりません。

上記の制限内であれば、@rcp{} は非常にパワフルです。注意しておかなければ
ならないのは、今現在は、エンドユーザー向けの洗練された製品とはほど遠い
状態であるということです。もうしばらくの間は、時々、ちょっと困った事に
なったり、コードに問題があるかもしれないということを念頭においておいて
ください。

すでに開発者が日々の作業に使う事ができる程度には安定しています。しかし、
インストールと設定を覚えるのは、専門用語のせいでほんの少し難しいでしょう。

@rcp{} は、まだアクティブに開発をしている最中です。したがって、どんな些細
な問題であっても、ぜひ @rcp{} 開発者に報告してください。
@xref{Bug Reports}.


@subsubheading 舞台の裏側

このセクションでは、@rcp{} でリモートファイルにアクセスした時に、舞台の
裏側で何がおこっているかを説明します。

@kbd{C-x C-f} とタイプし、@rcp{} のファイル名の一部を入力したとしましょう。
それから、ファイル名の補完のために @kbd{@key{TAB}} を押します。そして該当
ホストにたいして初めて @rcp{} を起動したとしましょう。この場合、以下の事が
おこります。

@itemize
@item
@rcp{} は、これが他のホストへの接続を必要とすることを発見します。それから
@command{telnet HOST} か @command{rsh HOST -l USER} あるいは、その他の
リモートホストへ接続するためのツールを起動します。これらのプロセスとの
コミュニケーションは Emacs のバッファーを経由しておこなわれます。したがって、
リモートホストからの出力はこのバッファーに出力されます。

@item
リモートホストは、ログイン名のプロンプトを表示します(@command{telnet} の場合)。
ログイン名は、入力されたファイル名に含まれているので、@rcp{} はログイン名と
改行を送信します。

@item
リモートホストは、パスワードあるいはパスフレーズのプロンプトを表示します
(これは@command{rsh} の場合、@command{telnet} の場合はログイン名を送信した後)。
@rcp{} はミニバッファーにプロンプトを表示し、パスワードまたはパスフレーズを
たずねます。

あなたがパスワードかパスフレーズを入力すると、@rcp はそれをリモートホストに
送信し、次に改行を送信します。

@item
@rcp{} は、シェルプロンプトか、ログインに失敗した旨のメッセージを待ちます。

もし、@rcp{} が、一定時間(たとえば一分)待っても、これらのメッセージを発見
することができなかったら、リモートシェルのプロンプトを発見できなかった旨の
メッセージを出力し、リモートホストが送信してきた内容を表示します。

もし、@rcp{} が「login failed」というメッセージを発見したら、それをあなた
に伝えます。それからログインを中止し、再びログインを試みることができます。

@item
ログインに成功し、@rcp{} がシェルプロンプトを発見したとします。ここで、
@rcp{} は @command{/bin/sh} を起動します。これは、Bourne シェルと C シェル
では文法体系が異なるためです。@footnote{ログインシェルが 
@command{exec /bin/sh} を正しいコマンドとして認識しないために、
@command{/bin/sh の起動}に失敗することがあるかもしれません。たぶん、あなた
は Scheme シェル @command{scsh} を使っているのでしょう@dots{}}

Bourne シェルが起動されたら、@rcp{} は、確実に動作する環境を準備するために
いくつかのコマンドを送信します。echo をオフにし、シェルプロンプトを設定した
り、その他いくつかの事をおこないます。

@item
今や、リモートシェルが起動し、きちんと動く状態になりました。
ところで、何がおこると期待されていたかを思いだしてください、
@rcp{} が、リモートホスト上にどのようなファイルが存在するかを調べ、
ファイル名の補完を可能にすることです。

そこで、@rcp{} は @command{cd} と @command{ls} コマンド、そして時々
globbing とともに @command{echo} を発行します。これ以外に、ファイルが書き
込み可能かどうか、ディレクトリかどうか等を調べるための @command{test} が、
しばしば使用されます。すべてのコマンドの出力は、必要なオペレーションのため
にパースされます。

@item
ファイル名の補完が完了し、@kbd{C-xC-f}と完全なファイル名を入力し、
@kbd{@key{RET}} を押したとしましょう。ファイルを編集するために、リモート
ホストからローカルホストにファイルの内容を転送する時が、ようやくやって
きました。

@rcp{} がどのようにファイルの内容を転送するのかという説明は、上を見て
ください。

インライン転送のために、@rcp{} は @command{mimencode -b /path/to/remote/file}
のようなコマンドを発行し、出力がコミュニケーションのためのバッファーに
蓄積されるまで待ちます。そして、ファイルの内容を作成するために、出力を
復号化します。

out-of-band 転送のために、@rcp{} は 
@command{rcp user@@host:/path/to/remote/file /tmp/rcp.4711} のようなコマンド
を発行します。そして、ローカルな一時ファイル @file{/tmp/rcp.4711} をバッファー
に読み込み、一時ファイルを削除します。

@item
今、あなたはバッファーの内容を編集しています。しかし、幸運にも舞台裏で何が
おこっているのかに気がつきません(このセクションを読むまでは、そうでしょう)。
作業が終り、バッファーを保存するために @kbd{C-x C-s} を押します。

@item
再び、@rcp{} はファイルの内容をリモートホストにインラインか out-of-band
で転送します。これは、ファイルを読み時におこっている事と逆です。

@end itemize

@rcp{} を使いファイルをオープンした時に、舞台裏でおこっている事の
基本的な概要を、この説明でわかってもらえることを願っています。


@c For the end user
@node Obtaining @rcp{}, Installation, Overview, Top
@chapter @rcp{} の入手方法

@rcp{} は、インターネット上でフリーに配布されています。最新版は
@url{ftp://ls6-ftp.cs.uni-dortmund.de/pub/src/emacs/rcp.tar.gz}
からダウンロード可能です。この中には、インストールに必要な @rcp 
のすべてのドキュメントとソースコードが含まれています。

冒険家のために @rcp{} は CVS から入手可能です。このバージョンは当然の
ことながら無保証です。犬を食べ、朝食を散歩につれていったり、苦情に対
してくすくす笑ってみたりするよりも、ひどいものかもしれません。自分の
責任で使用してください。:-)

@ifset ja
[訳者注] 犬を食べるうんぬんの部分はジョークです。CVS から入手するバージョン
はきちんと動かないかもしれないという事をユーモラスに表現しているだけです。
「朝食を多べて、犬の散歩をする」と「ジョークにたいしてくすくす笑う」という
親切(friendly or courteous)な行為を改変して、親切でない(ひどい)状態を表現
しているのでしょう。この文章を翻訳するのを助けてくれた Kai Grossjohann と
Daniel Pittman に感謝します。
@end ifset

@rcp {} の最新の開発バージョンを CVS (@command{cvs(1)}を参照してください)
から入手するためには、以下のコマンドを実行してください(ボールドの文字を
入力してください):

@example
] @strong{cd ~/lisp}
] @strong{cvs -d :pserver:cvs@@bonny.cs.uni-dortmund.de:/services/emacs-rcp/cvsroot login}
(Logging in to cvs@@bonny.cs.uni-dortmund.de)
CVS password: @strong{(just hit RET here)}
@dots{}

] @strong{cvs -d :pserver:cvs@@bonny.cs.uni-dortmund.de:/services/emacs-rcp/cvsroot get rcp}
@end example

これで、@rcp{} の最新バージョンが含まれるディレクトリ @file{~/lisp/rcp}
ができているはずです。以下のコマンドを実行することにより、最新のバージョン
に更新することができます:

@example
] @strong{cd ~/lisp/rcp}
] @strong{cvs update -d}
@end example



@node Installation, Configuration, Obtaining @rcp{}, Top
@chapter @rcp{} のインストール

@rcp {} をインストールするのは比較的簡単です。すくなくとも、あなたの
マシンを一から再構築するよりは。;)

真面目な話、インストール方法は非常にシンプルです。

@file{rcp.el} を Emacs の @var{load-path} に設定されているディレクトリ
へ置いた後、@rcp{} ライブラリーをロードするだけです。

@rcp {} と @command{efs} や @command{ange-ftp} パッケージの interactions
のために、@rcp{} パッケージが Emacs にロードされる@emph{前}に、これらの
パッケージは @emph{ロードされていなければなりません}。

もし、これらのパッケージをロードしていなければ、@rcp{} は、ひどく、
腹立だしい状態におちいります。これは、好ましくありません。

GNU Emacs では、以下のコマンドを @file{.emacs} に追加してください:

@example
(require 'ange-ftp)     @i{; GNU Emacs ships with this}
(require 'rcp)
@end example

XEmacs では、以下のものです:

@example
(require 'efs)          @i{; XEmacs uses EFS rather than ange-ftp}
(require 'rcp)
@end example


XEmacs ユーザーは、@command{fsf-compat} パッケージをインストールして
おかなければなりません。パッケージのインストール方法については、
@ref{Packages, , ,xemacs} を参照してください。



@node Configuration, Usage, Installation, Top
@chapter @rcp{} の設定


@rcp{} はインストール時に完全に機能する状態になっています。初期状態では、
リモートホストへの接続に @command{rsh} と @command{rcp} プログラムを使用
するように設定されています。

もし、リモートホストとの接続にこれらのコマンドを使用したくないのであれば、
@rcp{} のデフォルトの接続と転送メソッドを変更してください。@rcp{} がリモー
トマシンに接続し、ファイルを転送するのに使うことのできるメソッドがいくつか
あります。

転送メソッドには二つの基本的なタイプがあり、それぞれに長所、短所があります。
両者ともに、@command{rsh} や @command{ssh}、@command{telnet} のようなリモー
ト側のシェルにアクセスするプログラムを使用し、リモートマシンに接続します。

この接続は、@rcp{} がローカルマシンからリモートマシンへ透過的にアクセス
するためのさまざまなオペレーションをおこなうために使われます。ただし、
これは異なるファイルをオープンした時にだけ使われます。

リモートファイルを読み込んだり、保存する時には、二つのマシン間でファイル
の内容を転送する必要があります。ファイルの内容は、マシンにログインしたの
と同じ接続か、@command{rcp} や @command{scp}、@command{rsync}などのリモート
コピープログラムを使用した別の接続で転送されます。前者は 
@dfn{インラインメソッド}、後者は @dfn{外部転送メソッド}とよばれます。

外部転送メソッドの性能は、一般にインラインメソッドよりすぐれています。
インライン転送では、データの符号化、復号化をおこなう必要があるからです。

このルールの唯一の例外は、@command{scp} をもとにした転送メソッドです。
これらのメソッドは実際のファイル転送よりも高性能なので、転送開始時の
暗号化にかかわるネゴシエーションのオーバーヘッドは、ファイル転送時の
性能向上を帳消しにします。

外部転送メソッドを使うためには、リモートコピーコマンドが対話的でない、
つまりコマンドがパスワードのためにプロンプトを出力しないことが必要です。
もし、パスワード入力なしのリモートコピーコマンドを使う事ができないので
あれば、インラインメソッドを使う必要があります。

インラインメソッドの一種に、@dfn{マルチホップメソッド} があります。
このメソッドを使うと、リモートホストへ a number `hops' を使って、接続
できます。これは、あなたがセキュアなネットワークの中にいて、要塞ホスト
を経由して外部に接続する場合に便利です。

@menu
* Inline methods::              インラインメソッド
* External transfer methods::   外部転送メソッド
* Multi-hop Methods::           
* Default Method::              デフォルトのメソッドを選択する
* Customizing Methods::         
@end menu


@node Inline methods, External transfer methods, Configuration, Configuration
@section インラインメソッド

@ifset notyet
@rcp{} のインラインメソッドは大変強力で、外部転送メソッドを使う事ができ
ない状況でも動作します。インラインメソッドは、telnet 経由でリモートマシ
ンに接続している時に動作する唯一のメソッドです。(ホストでなく 
@emph{user identities} を使ったファイル転送が可能なメソッドもあります。
以下を参照してください。)
@end ifset
The inline methods in @rcp{} are quite powerful and can work in
situations where you cannot use an external transfer program to connect.
Inline methods are the only methods that work when connecting to the
remote machine via telnet.  (There are also strange inline methods which
allow you to transfer files between @emph{user identities} rather than
hosts, see below.)

@ifset notyet
これらのメソッドは、符号化、復号化のためのコマンドが、リモートマシン上に
存在することに依存します。ローカルマシン上では、@rcp{} は、ファイルを復号化、
符号化する Emacs の機能を使うか、外部コマンドを使用します。
@end ifset
These methods depend on the existence of a suitable encoding and
decoding command on remote machine. Locally, @rcp{} may be able to use
features of Emacs to decode and encode the files or it may require
access to external commands to perform that task.

@ifset notyet
@rcp{} は ファイル転送のために @command{uuencode} を使うことができます。
これはあまりお勧め @emph{できません}。@command{uuencode} と @command{uudecode}
コマンドは標準化が不十分です。すくなくともいくつかのマシン、AIX と IRIX を
あげておきますが、では正しく動作しないでしょう。これらのシステム上では、
@command{uuencode} が動きません。(@command{uuencode} のドキュメントにおける 
AIX に関する注意を見てください。)
@end ifset
@rcp{} supports the use of @command{uuencode} to transfer files. This is
@emph{not} recommended. The @command{uuencode} and @command{uudecode}
commands are not well standardized and may not function correctly or at
all on some machines, notably AIX and IRIX. These systems do not work
with @command{uuencode} at all.  (But do see the note about AIX in the
documentation for @var{rcp-methods}.)

@ifset notyet
簡単にいうと、もし、@command{mimencode} を base64 で符号化されたデータを
転送する時に使うことが可能なら、性能を向上あせるために、最近の Emacs で
組み込みのコマンドを使用することは有利です。
@end ifset
In summary, if possible use the @command{mimencode} methods to transfer
the data base64 encoded. This has the advantage of using a built-in
command in every modern Emacs, improving performance.

@itemize
@item @option{rm}  ---  @command{rsh} with @command{mimencode}

Connect to the remote host with @command{rsh} and use base64 encoding to
transfer files between the machines.

This requires the @command{mimencode} command that is part of the
@command{metamail} packages. This may not be installed on all remote
machines.


@item @option{sm}  ---  @command{ssh} with @command{mimencode}

Connect to the remote host with @command{ssh} and use base64 encoding to
transfer files between the machines.

This is identical to the previous option except that the @command{ssh}
package is used, making the connection more secure.

There are also two variants, @option{sm1} and @option{sm2} that use the
@command{ssh1} and @command{ssh2} commands explicitly. If you don't know
what these are, you do not need these options.


@item @option{tm}  ---  @command{telnet} with @command{mimencode}

Connect to the remote host with @command{telnet} and use base64 encoding
to transfer files between the machines.

This requires the @command{mimencode} command that is part of the
@command{metamail} packages.


@item @option{ru}  ---  @command{rsh} with @command{uuencode}

Connect to the remote host with @command{rsh} and use the
@command{uuencode} and @command{uudecode} commands to transfer files
between the machines.


@item @option{su}  ---  @command{ssh} with @command{uuencode}

Connect to the remote host with @command{ssh} and use the
@command{uuencode} and @command{uudecode} commands to transfer files
between the machines.

As with the @command{ssh} and base64 option above, this provides the
@option{su1} and @option{su2} methods to explicitly select an ssh
version.

Note that this method does not invoke the @command{su} program, see
below for methods which use that.


@item @option{tu}  ---  @command{telnet} with @command{uuencode}

Connect to the remote host with @command{telnet} and use the
@command{uuencode} and @command{uudecode} commands to transfer files
between the machines.


@item @option{sum} --- @command{su} with @command{mimencode}

This method does not connect to a remote host at all, rather it uses the
@command{su} program to allow you to edit files as another user.  Uses
base64 encoding to transfer the file contents.


@item @option{suu} --- @command{su} with @command{uuencode}

Like @option{sum}, this uses the @command{su} program to allow you to
edit files on the local host as another user.  Uses @command{uuencode}
and @command{uudecode} to transfer the file contents.


@item @option{sudm} --- @command{sudo} with @command{mimencode}

This is similar to the @option{sum} method, but it uses @command{sudo}
rather than @command{su} to become a different user.

Note that @command{sudo} must be configured to allow you to start a
shell as the user.  It would be nice if it was sufficient if
@command{ls} and @command{mimencode} were allowed, but that is not easy
to implement, so I haven't got around to it, yet.


@item @option{sudu} --- @command{sudo} with @command{uuencode}

This is similar to the @option{suu} method, but it uses @command{sudo}
rather than @command{su} to become a different user.


@end itemize



@node External transfer methods, Multi-hop Methods, Inline methods, Configuration
@section External transfer methods

The external transfer methods operate through multiple channels, using
the remote shell connection for many actions while delegating file
transfers to an external transfer utility.

This saves the overhead of encoding and decoding that multiplexing the
transfer through the one connection has with the inline methods.

If you want to use an external transfer method you @emph{must} be able
to execute the transfer utility to copy files to and from the remote
machine without any interaction.

This means that you will need to use @command{ssh-agent} if you use the
@command{scp} program for transfers. If you use @command{rsync} via
@command{ssh} then the same rule must apply to that connection.

If you cannot get @command{scp} to run without asking for a password but
would still like to use @command{ssh} to secure your connection, have a
look at the @command{ssh} based inline methods.


@itemize
@item @option{rcp}  ---  @command{rsh} and @command{rcp}

This method uses the @command{rsh} and @command{rcp} commands to connect
to the remote machine and transfer files. This is probably the fastest
connection method available.


@item @option{scp}  ---  @command{ssh} and @command{scp}

Using @command{ssh} to connect to the remote host and @command{scp} to
transfer files between the machines is the best method for securely
connecting to a remote machine and accessing files.

The performance of this option is also quite good. It may be slower than
the inline methods when you often open and close small files however.
The cost of the cryptographic handshake at the start of an @command{scp}
session can begin to absorb the advantage that the lack of encoding and
decoding presents.


@item @option{rsync}  ---  @command{ssh} and @command{rsync}

Using the @command{ssh} command to connect securely to the remote
machine and the @command{rsync} command to transfer files is almost
identical to the @option{scp} method.

While @command{rsync} performs much better than @command{scp} when
transferring files that exist on both hosts, this advantage is lost if
the file exists only on one side of the connection.

The @command{rsync} based method may be considerably faster than the
@command{rcp} based methods when writing to the remote system. Reading
files to the local machine is no faster than with a direct copy. 


@item @option{scpx} --- @command{ssh} and @command{scp}

As you expect, this is similar to @option{scp}, only a little
different.  Whereas @option{scp} opens a normal interactive shell on the
remote host, this option uses @command{ssh -t HOST -l user /bin/sh} to
open a connection.  This is useful for users where the normal login
shell is set up to ask them a number of question when logging in.  This
procedure avoids these questions, and just gives @rcp{} a more-or-less
`standard' login shell to work with. 

@end itemize

@node Multi-hop Methods, Default Method, External transfer methods, Configuration
@section Connecting to a remote host using multiple hops

Sometimes, the methods described before are not sufficient.  Sometimes,
it is not possible to connect to a remote host using a simple command.
For example, if you are in a secured network, you might have to log in
to a `bastion host' first before you can connect to the outside world.
Of course, the target host may also require a bastion host.  The format
of multi-hop filenames is slightly different than the format of normal
@rcp{} methods.

A multi-hop file name specifies a method, a number of hops, and a path
name on the remote system.  The method specifies how the file is
transferred through the inline connection.  The following two multi-hop
methods are available:

@itemize
@item @option{multi} --- base64 encoding with @command{mimencode}

The file is transferred through the connection in base64 encoding.  Uses
the @command{mimencode} program for doing encoding and decoding, but
uses an Emacs internal implementation on the local host if available.

@item @option{multiu} --- use commands @command{uuencode} and @command{uudecode}

The file is transferred through the connection in `uu' encoding.  Uses
the @command{uuencode} and @command{uudecode} programs for encoding and
decoding, but uses a Lisp implementation for decoding on the local host
if available.

@end itemize

Each hop consists of a @dfn{hop method} specification, a user name and a
host name.  The following hop methods are (currently) available:

@itemize
@item @option{telnet}

Uses the well-known @command{telnet} program to connect to the host.
Whereas user name and host name are supplied in the file name, the
user is queried for the password.

@item @option{rsh}

This uses @command{rsh} to connect to the host.  You do not need to
enter a password unless @command{rsh} explicitly asks for it.

@item @option{ssh}

This uses @command{ssh} to connect to the host.  You might have to enter
a password or a pass phrase.

@item @option{su}

This method does not actually contact a different host, but it allows
you to become a different user on the host you're currently on.  This
might be useful if you want to edit files as root, but the remote host
does not allow remote root logins.  In this case you can use
@option{telnet}, @option{rsh} or @option{ssh} to connect to the
remote host as a non-root user, then use an @option{su} hop to become
root.  But @option{su} need not be the last hop in a sequence, you could
also use it somewhere in the middle, if the need arises.

Even though you @emph{must} specify both user and host with a
@option{su} hop, the host name is ignored and only the user name is
used.

@item @option{sudo}

This is similar to the @option{su} hop, except that it uses
@command{sudo} rather than @command{su} to become a different user.

@end itemize



@node Default Method, Customizing Methods, Multi-hop Methods, Configuration
@section Selecting a default method

When you select an appropriate transfer method for your typical usage
you should set the variable @var{rcp-default-method} to reflect that
choice. This variable controls which method will be used when a method
is not specified in the @rcp{} file path.

External transfer methods are normally preferable to inline transfer
methods, giving better performance. They may not be useful if you use
many remote machines where you cannot log in without a password.

@xref{Inline methods}.
@xref{External transfer methods}.
@xref{Multi-hop Methods}.

Another consideration with the selection of transfer methods is the
environment you will use them in and, especially when used over the
Internet, the security implications of your preferred method.

The @command{rsh} and @command{telnet} methods send your password as
plain text as you log in to the remote machine, as well as transferring
the files in such a way that the content can easily be read from other
machines.

If you need to connect to remote systems that are accessible from the
Internet, you should give serious thought to using @command{ssh} based
methods to connect. These provide a much higher level of security,
making it a non-trivial exercise for someone to obtain your password or
read the content of the files you are editing.

@node Customizing Methods,  , Default Method, Configuration
@section Using Non-Standard Methods

There is a variable @code{rcp-methods} which you can change if the
predefined methods don't seem right.

For the time being, I'll refer you to the Lisp documentation of that
variable, accessible with @kbd{C-h v rcp-methods @key{RET}}.

@node Usage, Bug Reports, Configuration, Top
@chapter @rcp{} の使い方

Once you have installed @rcp{} it will operate fairly transparently. You
will be able to access files on any remote machine that you can log in
to as though they were local.

Files are specified to @rcp{} using a formalized syntax specifying the
details of the system to connect to. This is similar to the syntax used
by the @command{EFS} and @command{ange-ftp} packages.


@menu
* Filename Syntax::             @rcp{} filename conventions.
* Multi-hop filename syntax::   
* Dired::                       Dired and filename completion.
@end menu


@node Filename Syntax, Multi-hop filename syntax, Usage, Usage
@section @rcp{} filename conventions

To access the file <path> on the remote machine <machine> you would
specify the filename @file{/r:<machine>:<path>}. This will connect to
<machine> and transfer the file using the default method.
@xref{Default Method}.

Some examples of @rcp{} filenames are:

@table @file
@item /r:melancholia:.emacs
Edit the file @file{.emacs} in your home directory on the machine
@code{melancholia}.

@item /r:melancholia.danann.net:.emacs
This edits the same file, using the fully qualified domain name of
the machine.

@item /r:melancholia:~/.emacs
This also edits the same file --- the @file{~} is expanded to your
home directory on the remote machine, just like it is locally.

@item /r:melancholia:~daniel/.emacs
This edits the file @file{.emacs} in the home directory of the user
@code{daniel} on the machine @code{melancholia}. The @file{~<user>}
construct is expanded to the home directory of that user on the remote
machine.

@item /r:melancholia:/etc/squid.conf
This edits the file @file{/etc/squid.conf} on the machine
@code{melancholia}.

@end table


Unless you specify a different name to use, @rcp{} will use the current
local user name as the remote user name to log in with. If you need to
log in as a different user, you can specify the user name as part of the
filename.

To log in to the remote machine as a specific user, you use the syntax
@file{/r:<user>@@<machine>:/path/to.file}. That means that connecting to
@code{melancholia} as @code{daniel} and editing @file{.emacs} in your
home directory you would specify @file{/r:daniel@@melancholia:.emacs}.


It is also possible to specify other file transfer methods
(@pxref{Default Method}) as part of the filename. This is done by
replacing the initial @file{/r:} with @file{/r@@<method>:}. The user,
machine and file specification remain the same.

So, to connect to the machine @code{melancholia} as @code{daniel}, using
the @option{su} method to transfer files, and edit @file{.emacs} in my
home directory I would specify the filename
@file{/r@@su:daniel@@melancholia:.emacs}.


@node Multi-hop filename syntax, Dired, Filename Syntax, Usage
@section Multi-hop filename conventions

The syntax of multi-hop file names is necessarily slightly different
than the syntax of other @rcp{} file names.  Here's an example multi-hop
file name:

@file{/r@@multi:rsh#out@@gate:telnet#kai@@real.host:/path/to.file}

This is quite a mouthful.  So let's go through it step by step.  The
file name consists of three parts, separated by colons.  The first part
is @file{/r@@multi}, the method specification.  The second part is
@file{rsh#out@@gate:telnet#kai@@real.host} and specifies the hops.
(Yes, the second part may contain even more colons, so that's why this
file name has more than two colons in it.)  The final part is
@file{/path/to.file} and specifies the file name on the remote host.

The first part and the final part should be clear.  @ref{Multi-hop
Methods}, for a list of alternatives for the method specification.

The second part can be subdivided again into components, so-called hops.
In the above file name, there are two hops, @file{rsh#out@@gate} and
@file{telnet#kai@@real.host}.

Each hop can @emph{again} be subdivided into (three) components, the
@dfn{hop method}, the @dfn{user name} and the @dfn{host name}.  The
meaning of the second and third component should be clear, and the hop
method says what program to use to perfom that hop.

The first hop, @file{rsh#out@@gate}, says to use @command{rsh} to log in
as user @code{out} to the host @code{gate}.  Starting at that host, the
second hop, @file{telnet#kai@@real.host}, says to use @command{telnet}
to log in as user @code{kai} to host @code{real.host}.

@xref{Multi-hop Methods}, for a list of possible hop method values.  The
variable @var{rcp-multi-connection-function-alist} contains the list of
possible hop methods and information on how to execute them, should you
want to add your own.


@node Dired,  , Multi-hop filename syntax, Usage
@section Dired and filename completion

@rcp{} works transparently with dired, enabling you to use this powerful
file management tool to manage files on any machine you have access to
over the Internet.

Filename completion also works with @rcp{} for files on remote machines
although there is no completion for user names or machine names at this
stage.

As filename completion needs to fetch the listing of files from the
remote machine, this feature is sometimes fairly slow. As @rcp{} does not
yet cache the results of directory listing, there is no gain in
performance the second time you complete filenames.

If you need to browse a directory tree, Dired is a better choice, at
present, than filename completion. Dired has it's own cache mechanism
and will only fetch the directory listing once.


@node Bug Reports, Frequently Asked Questions, Usage, Top
@chapter バグや問題の報告

@rcp{} のバグや問題は、開発チームによってアクティブに解決されています。
仕様に関するリクエストや、提案も歓迎します。

@rcp{} メーリングリストは、@rcp{} の情報を入手したり、問題の解決や、
一般的な議論、そしてこのパッケージに関係する話題へのアドバイスに最適
の場所です。

メーリングリストは @email{emacs-rcp@@ls6.cs.uni-dortmund.de} です。
このアドレスにメッセージをを送ると、すべての講読者に届きます。
これは、講読のリクエストを送信するためのアドレスでは @emph{ありません}。

メーリングリストを講読するためのヘルプを入手するには、サブジェクトに
@samp{help} と書いたメールを管理用のアドレス
@email{emacs-rcp-request@@ls6.cs.uni-dortmund.de} に送信してください。

@rcp{} のバグ報告をする場合には、@kbd{M-x rcp-bug} を実行してください。
これは、あなたのシステムの詳細や @rcp{} のバージョン情報を含むバッファー
を自動的に生成します。

バグ報告を提出する時には、問題を再現する手順をわずらわしいぐらい詳細に
記述してください。もし可能なら、簡単な再現手順も記述してください。これら
は、開発チームがバグを突止め、修正するのを容易にします。


@node Frequently Asked Questions, Version Control, Bug Reports, Top
@chapter よくある質問とその答

@itemize @bullet
@item 最新の @rcp{} はどこから入手できますか?

@rcp{} は
@url{ftp://ls6-ftp.cs.uni-dortmund.de/pub/src/emacs/rcp.tar.gz}
にあります。


@item XEmacs で EFS が起動されてしまいます

すべての古いバージョンの @rcp{} が XEmacs を正しくサポートしているわけで
はありません。まず最初に、最新の @rcp{} がインストールされているかどうか
を確認してください。

もし最新のバージョンなら、@code{EFS} ハンドラーが実行されるための条件を
正確に調べてください。もし可能なら、ブレークポイントを @code{efs-ftp-path} 
に設定して、バグ報告と一緒にスタックトレースを送ってください。これらの情報
があると、何が間違っているのかを開発者が発見することが容易になります。

もし、あなたが非常に冒険心に富み、金の星 @footnote{もちろん、これを集める
ために、あなたはオーストラリアにきて、私を訪ねなければなりません。しかし、
誰がかぞえているのでしょうか?} などが好きならば、なぜ @rcp{} が正しく動
かないのかデバッグしてみてください。@code{rcp-file-name-handler} から
スタートすると良いでしょう。しかし、これは、本当に勇気のある人向きの方法です。

@ifset ja
[訳者注] 金の星うんぬんはジョークです。オーストラリアでは、良いことをした
小学生は金の星(ちいさなステッカー)をもらえるそうです。Thank you Daniel!
@end ifset

@item @rcp{} を使うとファイル名の補完ができません

リモートマシンにログインした時に、@command{ls} の出力が色付きになって
いませんか? もし、そうなら、それが原因です。

@command{ls} は、端末エミュレーターが色を変更するための @acronym{ANSI} 
エスケープシークエンスを出力します。しかしながら、このエスケープ
シークエンスは @rcp{} を混乱させます。

リモートマシン上の @file{.bashrc}、@file{.profile} あるいは同じような
設定ファイルに、@option{--color=yes} または @option{--color=auto}
が追加された設定の alias があるはずです。

この alias を削除し、新しくログインした時の @command{ls} の出力が
色付きで表示され @emph{ない} ことを確認してください。もし、これでも
ファイル名の補完が正常に動作しない場合は、@rcp{} 開発者にバグ報告を
してください。


@item @rcp{} はどのような種類のシステムで動作しますか

@rcp{} は、リモートシステムが Unix 風のシステムである事を当てにして
います。また、ローカルシステムも Unix 風のシステムのほうが望ましい
です。しかし、すこし修正すれば、@rcp{} は NT 上でも動作するでしょう。

@end itemize


@c For the developer
@node Version Control, Files directories and paths, Frequently Asked Questions, Top
@chapter リモートバージョンコントロールの内部動作

Unlike EFS and ange-ftp, @rcp{} has full shell access to the remote
machine. This makes it possible to provide version control for files
accessed under @rcp{}.

The actual version control binaries must be installed on the remote
machine, accessible in the directories specified in
@var{rcp-remote-path}.

This transparent integration with the version control systems is one of
the most valuable features provided by @rcp{}, but it is far from perfect.
Work is ongoing to improve the transparency of the system.

@menu
* Version Controlled Files::    Determining if a file is under version control.
* Remote Commands::             Executing the version control commands on the remote machine.
* Changed workfiles::           Detecting if the working file has changed.
* Checking out files::          Bringing the workfile out of the repository.
* Miscellaneous Version Control::  Things related to Version Control that don't fit elsewhere
@end menu


@node Version Controlled Files, Remote Commands, Version Control, Version Control
@section Determining if a file is under version control

The VC package uses the existence of on-disk revision control master
files to determine if a given file is under revision control. These file
tests happen on the remote machine through the standard @rcp{} mechanisms.


@node Remote Commands, Changed workfiles, Version Controlled Files, Version Control
@section Executing the version control commands on the remote machine

There are no hooks provided by VC to allow intercepting of the version
control command execution. The calls occur through the
@code{call-process} mechanism, a function that is somewhat more
efficient than the @code{shell-command} function but that does not
provide hooks for remote execution of commands.

To work around this, the functions @code{vc-do-command} and
@code{vc-simple-command} have been advised to intercept requests for
operations on files accessed via @rcp{}.

In the case of a remote file, the @code{shell-command} interface is
used, with some wrapper code, to provide the same functionality on the
remote machine as would be seen on the local machine. 


@node Changed workfiles, Checking out files, Remote Commands, Version Control
@section Detecting if the working file has changed

As there is currently no way to get access to the mtime of a file on a
remote machine in a portable way, the @code{vc-workfile-unchanged-p}
function is advised to call an @rcp{} specific function for remote files.

The @code{rcp-vc-workfile-unchanged-p} function uses the functioning VC
diff functionality to determine if any changes have occurred between the
workfile and the version control master.

This requires that a shell command be executed remotely, a process that
is notably heavier-weight than the mtime comparison used for local
files. Unfortunately, unless a portable solution to the issue is found,
this will remain the cost of remote version control.


@node Checking out files, Miscellaneous Version Control, Changed workfiles, Version Control
@section Bringing the workfile out of the repository

VC will, by default, check for remote files and refuse to act on them
when checking out files from the repository. To work around this
problem, the function @code{vc-checkout} knows about @rcp{} files and
allows version control to occur.


@node Miscellaneous Version Control,  , Checking out files, Version Control
@section Things related to Version Control that don't fit elsewhere

Minor implementation details, &c.

@menu
* Remote File Ownership::       How VC determines who owns a workfile.
* Back-end Versions::           How VC determines what release your RCS is.
@end menu


@node Remote File Ownership, Back-end Versions, Miscellaneous Version Control, Miscellaneous Version Control
@subsection How VC determines who owns a workfile

Emacs provides the @code{user-full-name} function to return the login name
of the current user as well as mapping from arbitrary user id values
back to login names. The VC code uses this functionality to map from the
uid of the owner of a workfile to the login name in some circumstances.

This will not, for obvious reasons, work if the remote system has a
different set of logins. As such, it is necessary to delegate to the
remote machine the job of determining the login name associated with a
uid.

Unfortunately, with the profusion of distributed management systems such
as @code{NIS}, @code{NIS+} and @code{NetInfo}, there is no simple,
reliable and portable method for performing this mapping.

Thankfully, the only place in the VC code that depends on the mapping of
a uid to a login name is the @code{vc-file-owner} function. This returns
the login of the owner of the file as a string.

This function has been advised to use the output of @command{ls} on the
remote machine to determine the login name, delegating the problem of
mapping the uid to the login to the remote system which should know more
about it than I do.


@node Back-end Versions,  , Remote File Ownership, Miscellaneous Version Control
@subsection How VC determines what release your RCS is

VC needs to know what release your revision control binaries you are
running as not all features VC supports are available with older
versions of @command{rcs(1)}, @command{cvs(1)} or @command{sccs(1)}.

The default implementation of VC determines this value the first time it
is needed and then stores the value globally to avoid the overhead of
executing a process and parsing it's output each time the information is
needed.

Unfortunately, life is not quite so easy when remote version control
comes into the picture. Each remote machine may have a different version
of the version control tools and, while this is painful, we need to
ensure that unavailable features are not used remotely.

To resolve this issue, @rcp{} currently takes the sledgehammer
approach of making the release values of the revision control tools
local to each @rcp{} buffer, forcing VC to determine these values
again each time a new file is visited.

This has, quite obviously, some performance implications. Thankfully,
most of the common operations performed by VC do not actually require
that the remote version be known. This makes the problem far less
apparent.

Eventually these values will be captured by @rcp{} on a system by
system basis and the results cached to improve performance.


@node Files directories and paths, Issues, Version Control, Top
@chapter ファイル名、ディレクトリ、パス名がどのように変換され(mangled)、管理されるか

@menu
* Path deconstruction::         Breaking a path into it's components.
@end menu


@node Path deconstruction,  , Files directories and paths, Files directories and paths
@section Breaking a path into it's components.

@rcp{} filenames are somewhat different, obviously, to ordinary path
names. As such, the lisp functions @code{file-name-directory} and
@code{file-name-nondirectory} are overridden within the @rcp{} package.

Their replacements are reasonably simplistic in their approach. They
dissect the filename, call the original handler on the remote path and
then rebuild the @rcp{} path with the result.

This allows the platform specific hacks in the original handlers to take
effect while preserving the @rcp{} path information.


@node Issues,  , Files directories and paths, Top
@chapter 検討課題と決定事項

@itemize @bullet
@item The uuencode method does not always work.

Due to the design of @rcp{}, the encoding and decoding programs need to
read from stdin and write to stdout.  On some systems, @code{uudecode -o
-} will read stdin and write the decoded file to stdout, on other
systems @code{uudecode -p} does the same thing.  But some systems have
uudecode implementations which cannot do this at all---it is not
possible to call these uudecode implementations with suitable parameters
so that they write to stdout.

Of course, this could be circumvented: the @code{begin foo 644} line
could be rewritten to put in some temporary file name, then
@code{uudecode} could be called, then the temp file could be printed and
deleted.

But I have decided that this is too fragile to reliably work, so on some
systems you'll have to do without the uuencode methods.

@item @rcp{} does not work on XEmacs 20.

This is because it requires the macro @code{with-timeout} which does not
appear to exist in XEmacs 20.  I'm somewhat reluctant to add an
emulation macro to @rcp{}, but if somebody who uses XEmacs 20 steps
forward and wishes to implement and test it, please contact me or the
mailing list.

@end itemize


@c End of rcp_ja.texi - the RCP User Manual
@bye

@c TODO
@c
@c * Say something about the .login and .profile files of the remote
@c   shells.
@c * Explain how rcp.el works in principle: open a shell on a remote
@c   host and then send commands to it.

@c Local Variables:
@c eval: (add-hook 'write-file-hooks 'time-stamp)
@c time-stamp-start: "@set UPDATED "
@c time-stamp-format: "%:y 年 %:m 月 %:d 日 (%3a)"
@c time-stamp-end: "$"
@c time-stamp-line-limit: 50
@c End:
